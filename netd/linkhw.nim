import netd/core, netd/link, netd/iproute
import conf/ast
import commonnim
import nre, options

type
  LinkHwPlugin* = ref object of Plugin

proc create*(t: typedesc[LinkHwPlugin], manager: NetworkManager): LinkHwPlugin =
  new(result)
  result.manager = manager

proc matchInterfacesByDeviceName(interfaces: seq[LivingInterface], name: string): seq[LivingInterface] =
  result = @[]
  let regexp = re(name & "$")
  # Match interfaces
  for miface in interfaces:
    var iface = miface
    if iface.isSynthetic:
      # This can't be a hardware interface, it's marked as created by us
      continue

    if iface.abstractName == nil and not iface.namespaceName.isRootNamespace:
      # We haven't moved this interface into other namespace, so it's probably
      # generated by something like LXC
      continue

    # Approximation of the original interface name
    if iface.abstractName == nil:
      iface.abstractName = iface.kernelName

    if iface.abstractName.match(regexp).isSome:
      result.add iface

proc matchInterfaces(interfaces: seq[LivingInterface], matcher: Command): seq[LivingInterface] =
  case matcher.name:
  of "dev":
    let name = unpackSeq1(matcher.args).value.stringValue
    return matchInterfacesByDeviceName(interfaces, name)
  else: assert false

proc gatherInterfacesWithConfigs(self: LinkHwPlugin): ManagedInterfaceWithConfigSeq =
  result = @[]

  let interfaces = self.getPlugin(LinkManager).listLivingInterfaces()

  let configRoot = self.manager.config
  for topCommand in configRoot.commandsWithName("link"):
    let (matcherVal, bodyVal) = unpackSeq2(topCommand.args)
    let matcher = matcherVal.command
    let body = bodyVal.suite

    for livingIface in matchInterfaces(interfaces, matcher):
      let interfaceName: InterfaceName = livingIface.interfaceName
      # TODO: do this in setupInterfaces
      writeAliasProperties(interfaceName,
                           makeAliasProperties(isSynthetic=false, abstractName=livingIface.abstractName))
      let newName: InterfaceName = interfaceName.applyRename(body)
      let managedInterface = ManagedInterface(
        kernelName: newName.name,
        namespaceName: newName.namespace,
        isSynthetic: false,
        abstractName: livingIface.abstractName
      )
      result.add((iface: managedInterface, config: body))

method gatherInterfaces*(self: LinkHwPlugin): seq[ManagedInterface] =
  self.getPlugin(LinkManager).gatherInterfacesRecursive(self.gatherInterfacesWithConfigs)

method setupInterfaces*(self: LinkHwPlugin) =
  for v in self.gatherInterfacesWithConfigs():
    let (iface, config) = v
    self.getPlugin(LinkManager).cleanupInterfaceAll(iface, config)
    self.getPlugin(LinkManager).configureInterfaceAll(iface, config)
